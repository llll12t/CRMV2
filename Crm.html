<!DOCTYPE html>
<html lang="th" data-theme="light">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>CRM-3RN</title>
  <!-- Load config before main script -->
  <script src="Config.js"></script>
  <!-- LIFF SDK -->
  <script src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>
  <!-- DaisyUI CDN (includes Tailwind CSS) -->
  <link href="https://cdn.jsdelivr.net/npm/daisyui@latest/dist/full.css" rel="stylesheet" type="text/css" />
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <!-- QR Code Generator Library -->
  <script src="https://cdn.jsdelivr.net/npm/qrcode-generator/qrcode.js"></script>

  <style>
    /* General styles */
    body {
      background: linear-gradient(to bottom, theme('colors.neutral') 0%, theme('colors.white') 50%, theme('colors.white') 100%);
      background-attachment: fixed;
      min-height: 100vh;
      padding: 1.5rem; /* p-6 */
    }
    .hidden { display: none !important; }

    /* Neon text for points */
    .neon-text {
      color: #fff;
      text-shadow: 0 0 5px #ff005e, 0 0 10px #ff005e, 0 0 20px #ff005e, 0 0 40px #ff005e, 0 0 80px #ff005e;
      animation: glow 1.5s infinite alternate;
    }
    @keyframes glow {
      from { text-shadow: 0 0 5px #ff005e, 0 0 10px #ff005e, 0 0 20px #ff005e; }
      to { text-shadow: 0 0 10px #00d4ff, 0 0 20px #00d4ff, 0 0 40px #00d4ff; }
    }

    /* Loading skeleton animation */
    @keyframes pulse-opacity {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }
    .loading-card-animation { animation: pulse-opacity 1.5s infinite ease-in-out; }

    /* Glassmorphism effect */
    .glass-white {
      background: rgba(255, 255, 255, 0.15);
      box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(8.1px);
      -webkit-backdrop-filter: blur(8.1px);
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    /* Additional styles for QR container when showing text */
    #qrcode.text-status {
        min-height: 150px; /* Ensure space even if no QR */
        display: flex;
        align-items: center;
        justify-content: center;
    }
  </style>
</head>

<body>
  <!-- Header -->
  <div class="flex justify-between items-center mb-6">
    <h2 id="pageTitle" class="text-xl font-bold text-white">กำลังโหลด...</h2>
    <div class="glass-white rounded-full flex items-center p-1 space-x-2">
      <div id="pointVal" class="font-bold neon-text text-lg px-2">0</div>
      <img id="lineDisplayPicture" class="mask mask-circle w-10 h-10 rounded-full object-cover border border-black" src="https://img.daisyui.com/images/stock/photo-1567653418876-5bb0e566e1c2.webp" />
    </div>
  </div>

  <!-- Main App Container -->
  <div id="app">
    <div class="text-center text-gray-100 py-8">กำลังโหลดเนื้อหา...</div>
  </div>

  <!-- Dialogs -->
  <dialog id="customAlertDialog" class="modal">
    <div class="modal-box text-center">
      <h3 id="customAlertTitle" class="font-bold text-lg mb-3"></h3>
      <p id="customAlertMessage" class="py-4 whitespace-pre-line"></p>
      <div class="modal-action justify-center">
        <button id="customAlertButton" class="btn btn-neutral w-full">ตกลง</button>
      </div>
    </div>
  </dialog>

  <dialog id="customConfirmDialog" class="modal">
    <div class="modal-box text-center">
      <h3 id="customConfirmTitle" class="font-bold text-lg mb-3"></h3>
      <p id="customConfirmMessage" class="py-4"></p>
      <div class="modal-action justify-around">
        <button id="customConfirmCancelButton" class="btn btn-outline btn-neutral">ยกเลิก</button>
        <button id="customConfirmConfirmButton" class="btn btn-neutral">ยืนยัน</button>
      </div>
    </div>
  </dialog>

  <!-- QR Code Dialog (for Warehouse) -->
  <dialog id="qrDialog" class="modal">
    <div class="modal-box text-center">
      <h3 id="qrDialogTitle" class="font-bold text-lg mb-2">สแกนเพื่อรับของ</h3>
      <p id="qrDialogItemName" class="mb-4 text-sm text-gray-600"></p> <!-- ใช้แสดง Item Name และ Unique ID -->
      <div id="qrcode" class="flex justify-center mb-4 p-4 bg-white rounded-lg"></div>
      <p class="text-xs text-gray-500 mb-4" id="qrDialogDescription">ให้พนักงานสแกน QR Code นี้เพื่อตรวจสอบและยืนยันการรับสินค้า</p>
      <div class="modal-action justify-around">
         <!-- เพิ่มปุ่มแชร์ -->
        <button id="shareQrBtn" class="btn btn-outline btn-primary hidden">แชร์ QR ไปยัง LINE OA</button>
        <button id="qrDialogCloseBtn" class="btn btn-outline">ปิด</button>
        <!-- ปุ่มยืนยันจะถูกซ่อนด้วย JavaScript เพราะเราจะใช้ระบบตรวจสอบอัตโนมัติ -->
        <button id="qrDialogConfirmBtn" class="btn btn-neutral hidden">ยืนยันการรับของ</button>
      </div>
    </div>
  </dialog>

  <!-- Template: Dashboard (Main Menu) -->
  <template id="view-dashboard">
    <div class="glass-white rounded p-4 grid grid-cols-3 gap-3 text-center text-sm font-medium mb-6">
      <a href="#event" class="bg-white text-black p-3 rounded flex flex-col items-center justify-center space-y-1">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z" /></svg>
        <span>กิจกรรม</span>
      </a>
      <a href="#warehouse" class="bg-white text-black p-3 rounded flex flex-col items-center justify-center space-y-1">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4" /></svg>
        <span>คลัง</span>
      </a>
      <a href="#addpoint" class="bg-white text-black p-3 rounded flex flex-col items-center justify-center space-y-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="h-6 w-6" fill="none"><path d="M2.5 8.18677C2.60406 6.08705 2.91537 4.77792 3.84664 3.84664C4.77792 2.91537 6.08705 2.60406 8.18677 2.5M21.5 8.18677C21.3959 6.08705 21.0846 4.77792 20.1534 3.84664C19.2221 2.91537 17.9129 2.60406 15.8132 2.5M15.8132 21.5C17.9129 21.3959 19.2221 21.0846 20.1534 20.1534C21.0846 19.2221 21.3959 17.9129 21.5 15.8132M8.18676 21.5C6.08705 21.3959 4.77792 21.0846 3.84664 20.1534C2.91537 19.2221 2.60406 17.9129 2.5 15.8132" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"></path><path d="M2.49986 12H21.4999" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"></path><path d="M6 12C6 8.68629 8.68629 6 12 6C12 7.65685 13.3431 9 15 9C15.6755 9 16.2989 8.77672 16.8004 8.39993C17.5536 9.40273 18 10.6492 18 12M17.1973 15C16.1599 16.7934 14.2208 18 12 18C9.77915 18 7.84012 16.7934 6.80269 15" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg>
        <span>สแกนรับ</span>
      </a>
      <a href="#transfer" class="bg-white text-black p-3 rounded flex flex-col items-center justify-center space-y-1">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4" /></svg>
        <span>โอนพ้อย</span>
      </a>
      <a href="#redeem" class="bg-white text-black p-3 rounded flex flex-col items-center justify-center space-y-1">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v13m0-13V6a2 2 0 112 2h-2zm0 0V5.5A2.5 2.5 0 109.5 8H12zm-7 4h14M5 12a2 2 0 110-4h14a2 2 0 110 4M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7" /></svg>
        <span>แลกพ้อย</span>
      </a>
      <a href="#profile" class="bg-white text-black p-3 rounded flex flex-col items-center justify-center space-y-1">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" /></svg>
        <span>บัญชี</span>
      </a>
    </div>

    <div id="checkinBox" class="flex items-center justify-between mb-8 hidden">
      <div class="bg-gray-100 rounded-full px-4 py-2 flex items-center space-x-2 text-gray-700">
        <span class="text-sm">วันที่</span><span id="todayDate" class="font-bold text-md">00</span>
      </div>
      <div class="bg-yellow-400 rounded-full w-10 h-10 flex items-center justify-center text-white font-bold text-sm">+1</div>
      <button id="checkinBtn" class="btn btn-neutral btn-sm">เช็คอิน</button>
    </div>

    <div>
      <div class="flex justify-between items-center mb-4">
        <div class="font-bold text-lg">รายการล่าสุด</div>
        <div class="text-xs text-gray-400 font-medium">POINT</div>
      </div>
      <ul id="historyList" class="space-y-4"></ul>
    </div>
  </template>

  <!-- Template: Event List -->
  <template id="view-event">
    <div id="eventList" class="space-y-3"></div>
  </template>

  <!-- Template: Event Detail -->
  <template id="view-event-detail">
    <div id="cardWrapper">
      <div id="cardSkeleton" class="bg-white p-6 rounded shadow-md mb-6 animate-pulse"><div class="h-6 bg-gray-200 rounded w-1/3 mb-4"></div><div class="h-4 bg-gray-200 rounded w-1/4 mb-2"></div><div class="h-3 bg-gray-200 rounded w-full mb-6"></div><div class="h-12 bg-gray-200 rounded-full w-full"></div></div>
      <div id="card" class="bg-white p-6 rounded shadow-md text-gray-800 mb-6 hidden">
        <div class="flex justify-between items-start mb-3"><div class="font-bold text-lg" id="eventDetailTitle">–</div><div class="bg-yellow-400 text-black font-bold text-md px-3 py-1 rounded-full" id="eventPoint">0+</div></div>
        <div class="text-sm text-gray-700 mb-6 leading-relaxed" id="eventDetailDesc">...</div>
        <button id="joinBtn" class="btn btn-neutral w-full">เข้าร่วม</button>
      </div>
    </div>
  </template>

  <!-- Template: Profile -->
  <template id="view-profile">
    <div class="space-y-4">
      <div class="glass-white p-6 rounded-lg text-center shadow-md">
        <div class="relative w-24 h-24 mx-auto mb-4">
          <img id="profileDisplayPicture" class="mask mask-circle w-24 h-24 rounded-full object-cover border-4 border-black" src="https://img.daisyui.com/images/stock/photo-1567653418876-5bb0e566e1c2.webp" alt="รูปโปรไฟล์" />
          <button id="editProfileBtn" class="absolute bottom-0 right-0 bg-white rounded-full p-1.5 shadow-md hover:scale-110 transition-transform"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-600" viewBox="0 0 20 20" fill="currentColor"><path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.389-8.389-2.828-2.828z" /></svg></button>
        </div>
        <div class="text-2xl font-bold mb-2" id="profileDisplayName">กำลังโหลด...</div>
        <div class="flex items-center justify-center space-x-2 mb-2"><span id="profileLevelBadge" class="badge badge-lg"></span><span id="profileCustomTagBadge" class="badge badge-lg"></span></div>
        <progress id="profileProgressBar" class="progress progress-warning w-full" value="0" max="100"></progress>
        <div id="profilePointsToNextLevel" class="text-sm text-gray-700 mt-1"></div>
        <div class="font-bold text-xl mt-4">รวมพ้อยต์: <span id="profileTotalPoints">0</span></div>
      </div>
      <div id="profileFormContainer" class="bg-white p-6 rounded-lg shadow-md space-y-4 hidden">
        <div><label class="block text-sm font-medium text-gray-700 mb-1">LINE ID</label><input id="profileLineId" readonly class="input input-bordered w-full cursor-not-allowed text-gray-500" /></div>
        <div><label class="block text-sm font-medium text-gray-700 mb-1">ชื่อ</label><input id="profileName" readonly class="input input-bordered w-full cursor-not-allowed text-gray-500" /></div>
        <div><label class="block text-sm font-medium text-gray-700 mb-1">เบอร์โทรศัพท์</label><input id="profilePhone" readonly class="input input-bordered w-full cursor-not-allowed text-gray-500" /></div>
        <div><label class="block text-sm font-medium text-gray-700 mb-1">อีเมล</label><input id="profileEmail" readonly class="input input-bordered w-full cursor-not-allowed text-gray-500" /></div>
        <div><label class="block text-sm font-medium text-gray-700 mb-1">ที่อยู่</label><input id="profileAddress" readonly class="input input-bordered w-full cursor-not-allowed text-gray-500" /></div>
        <div><label class="block text-sm font-medium text-gray-700 mb-1">หมายเหตุ</label><input id="profileNote" readonly class="input input-bordered w-full cursor-not-allowed text-gray-500" /></div>
        <div id="profileEditButtons" class="flex space-x-2 hidden"><button id="saveProfileBtn" class="btn btn-neutral flex-1">บันทึกข้อมูล</button><button id="cancelEditBtn" class="btn btn-outline btn-neutral flex-1">ยกเลิก</button></div>
      </div>
    </div>
  </template>

  <!-- Template: Redeem -->
  <template id="view-redeem">
    <div class="p-0"><ul id="redeemList" class="grid grid-cols-2 gap-4"></ul></div>
  </template>

  <!-- Template: Transfer -->
  <template id="view-transfer">
    <div class="space-y-4 mb-6">
      <input id="transferTo" placeholder="LINE ID เพื่อน / เบอร์โทรปลายทาง" type="text" class="input input-bordered input-neutral w-full">
      <input id="transferAmount" placeholder="จำนวนพ้อยที่ต้องการโอน" type="number" class="input input-bordered input-neutral w-full">
      <button id="transferBtn" class="btn btn-neutral w-full">โอนพ้อย</button>
    </div>
  </template>

  <!-- Template: Warehouse -->
  <template id="view-warehouse">
    <ul id="warehouseList" class="space-y-3"></ul>
  </template>

  <!-- Template: Add Points (Scan/Manual Code) -->
  <template id="view-addpoint">
    <div id="scanContainer" class="space-y-4 mb-6">
      <button id="scanBtn" class="btn btn-neutral w-full">สแกน QR Code</button>
      <div class="flex space-x-2">
        <input id="manualCode" type="text" placeholder="กรอกโค้ดที่นี่" class="input input-bordered input-neutral flex-1">
        <button id="enterBtn" class="btn btn-neutral">รับโค้ด</button>
      </div>
    </div>
  </template>

<!-- Shipping Form Dialog (for Physical Items) -->
<dialog id="shippingFormDialog" class="modal">
  <div class="modal-box">
    <h3 id="shippingFormTitle" class="font-bold text-lg mb-4">ข้อมูลสำหรับจัดส่ง</h3>
    <div class="space-y-4">
      <div>
        <label class="label"><span class="label-text">ชื่อ-นามสกุล ผู้รับ</span></label>
        <input id="shippingName" type="text" placeholder="กรอกชื่อ-นามสกุล" class="input input-bordered w-full" />
      </div>
      <div>
        <label class="label"><span class="label-text">เบอร์โทรศัพท์ติดต่อ</span></label>
        <input id="shippingPhone" type="tel" placeholder="กรอกเบอร์โทรศัพท์" class="input input-bordered w-full" />
      </div>
      <div>
        <label class="label"><span class="label-text">ที่อยู่สำหรับจัดส่ง</span></label>
        <textarea id="shippingAddress" class="textarea textarea-bordered w-full" rows="4" placeholder="บ้านเลขที่, ถนน, ตำบล, อำเภอ, จังหวัด, รหัสไปรษณีย์"></textarea>
      </div>
    </div>
    <div class="modal-action justify-between mt-6">
      <button id="shippingFormCancelBtn" class="btn btn-outline">ยกเลิก</button>
      <button id="shippingFormConfirmBtn" class="btn btn-neutral">ยืนยันและแลกของ</button>
    </div>
  </div>
</dialog>

<script>
    // --- GLOBAL STATE & CACHE ---
    let liffInitialized = false;
    const userState = { profile: null, lineId: "", points: 0, pointsChanged: false, level: "Member", customTag: "" };
    const dataCache = { events: null, redeemItems: null, eventDetails: {}, userProfileFull: null, history: null, levelSettings: null };
    // เพิ่มตัวแปรสำหรับเก็บ polling interval
    let warehousePollingInterval = null;

    // --- DIALOGS & UI ELEMENTS ---
    const alertDialog = document.getElementById('customAlertDialog'), alertT = document.getElementById('customAlertTitle'), alertM = document.getElementById('customAlertMessage'), alertBtn = document.getElementById('customAlertButton');
    const confirmDialog = document.getElementById('customConfirmDialog'), confT = document.getElementById('customConfirmTitle'), confM = document.getElementById('customConfirmMessage'), okBtn = document.getElementById('customConfirmConfirmButton'), noBtn = document.getElementById('customConfirmCancelButton');
    const pageTitleEl = document.getElementById('pageTitle'), pointValEl = document.getElementById('pointVal'), dpEl = document.getElementById('lineDisplayPicture');
    // อ้างอิง Dialog QR และ Element ภายใน
    const qrDialog = document.getElementById('qrDialog'),
          qrDialogTitle = document.getElementById('qrDialogTitle'),
          qrDialogItemName = document.getElementById('qrDialogItemName'),
          qrcodeContainer = document.getElementById('qrcode'),
          qrDialogDescription = document.getElementById('qrDialogDescription'),
          qrConfirmBtn = document.getElementById('qrDialogConfirmBtn'),
          qrCloseBtn = document.getElementById('qrDialogCloseBtn'),
          shareQrBtn = document.getElementById('shareQrBtn');


    // --- STYLES ---
    const LEVEL_STYLES = { 'Member': { text: 'Member', class: 'badge-info badge-outline' }, 'VIP': { text: 'VIP', class: 'badge-primary badge-outline' }, 'Super': { text: 'Super', class: 'badge-success badge-outline' } };
    const CUSTOM_TAG_STYLES = { 'newuser': { class: 'badge-warning', text: 'สมาชิกใหม่' }, 'ceo': { class: 'badge-accent', text: 'CEO' }, 'admin': { class: 'badge-error', text: 'ผู้ดูแล' }, 'tester': { class: 'badge-secondary', text: 'ผู้ทดสอบ' }, 'default': { class: 'badge-neutral', text: '' } };

    // --- COMMON UI FUNCTIONS ---
    function showAlert(title, message, cb) {
      alertT.textContent = title; alertM.textContent = message; alertDialog.showModal();
      const hide = () => { alertDialog.close(); alertBtn.removeEventListener('click', hide); cb && cb(); };
      alertBtn.addEventListener('click', hide);
    }
    function showConfirm(title, message) {
      return new Promise(res => {
        confT.textContent = title; confM.textContent = message; confirmDialog.showModal();
        const onOk = () => { cleanup(); res(true); }; const onNo = () => { cleanup(); res(false); };
        function cleanup() { confirmDialog.close(); okBtn.removeEventListener('click', onOk); noBtn.removeEventListener('click', onNo); }
        okBtn.addEventListener('click', onOk); noBtn.addEventListener('click', onNo);
      });
    }

    // --- DATA & STATE MANAGEMENT ---
    function calculateLevelAndProgress(currentPoints) {
      const vipPoints = dataCache.levelSettings?.VIP_points || 5000;
      const superPoints = dataCache.levelSettings?.SUPER_points || 10000;
      let level = 'Member', currentLevelMin = 0, nextLevelMin = vipPoints, nextLevelName = 'VIP';
      if (currentPoints >= superPoints) { level = 'Super'; currentLevelMin = superPoints; nextLevelMin = currentPoints; nextLevelName = ''; }
      else if (currentPoints >= vipPoints) { level = 'VIP'; currentLevelMin = vipPoints; nextLevelMin = superPoints; nextLevelName = 'Super'; }
      const pointsInCurrentTier = currentPoints - currentLevelMin; const pointsToNextTier = nextLevelMin - currentLevelMin;
      let progressValue = 0, pointsNeeded = 0;
      if (nextLevelName) { progressValue = (pointsInCurrentTier / pointsToNextTier) * 100; pointsNeeded = nextLevelMin - currentPoints; }
      else { progressValue = 100; pointsNeeded = 0; }
      return { level, progressValue: Math.min(100, Math.max(0, progressValue)), pointsToNext: pointsNeeded, nextLevelName };
    }
    function setBadgeContent(badgeElement, text, className) {
      if (!badgeElement) return; badgeElement.textContent = text; badgeElement.className = className;
      if (text) badgeElement.classList.remove('hidden'); else badgeElement.classList.add('hidden');
    }
    async function fetchAndUpdateUserState() {
      try {
        const userRes = await fetch(`${CONFIG.GAS_URL}?action=getUserInfo&lineId=${userState.lineId}`);
        const userData = await userRes.json();
        if (userData && !userData.error) {
          userState.points = parseInt(userData.point || 0, 10);
          userState.level = userData.level || 'Member';
          userState.customTag = userData.customTag || '';
          dataCache.userProfileFull = userData;
          pointValEl.textContent = userState.points;
          userState.pointsChanged = true;
          console.log(`User state updated: Points=${userState.points}, Level=${userState.level}, Tag=${userState.customTag}`);
        } else { console.error("Failed to fetch user data after action:", userData?.error || "Unknown error"); }
      } catch (e) { console.error("Error fetching user info after action:", e); }
    }

    // --- LIFF & APP INITIALIZATION ---
    async function ensureLIFFAndFetchInitialData() {
      if (!liffInitialized) {
        try {
            await liff.init({ liffId: CONFIG.LIFF_ID });
            liffInitialized = true;
            console.log('LIFF Init successful');

            // Check if share API is available AFTER successful LIFF init
            try {
                 console.log('Checking share API availability...');
                 if (liff.isApiAvailable('shareTargetPicker') || liff.isApiAvailable('sendMessage')) {
                     // This check is done later within handleClaimButtonClick now,
                     // as the button is only relevant in the Warehouse view modal.
                     // Leaving this here is fine, but the primary visibility check is tied to the modal.
                      console.log('Share API is available.');
                 } else {
                      console.log('Share API is NOT available.');
                 }
            } catch (apiError) {
                 console.error("Error checking LIFF API availability:", apiError);
                 // No need to hide button here globally, handle in view init/modal open
            }

        } catch (e) {
            console.error("LIFF initialization failed:", e);
            showAlert("ข้อผิดพลาด", "ไม่สามารถเริ่มต้น LIFF ได้ กรุณาลองใหม่ภายหลัง");
            return false;
        }
      }

      // Check login status
      if (!liff.isLoggedIn()) {
          console.log("LIFF not logged in, redirecting to login.");
          liff.login();
          return false;
      }

      // Get Profile (if not already obtained)
      if (!userState.profile) {
          try {
            userState.profile = await liff.getProfile();
            userState.lineId = userState.profile.userId;
            dpEl.src = userState.profile.pictureUrl || 'https://via.placeholder.com/40';
            dpEl.alt = `รูปโปรไฟล์ของ ${userState.profile.displayName}`;
            console.log(`Got LIFF profile for user: ${userState.lineId}`);
          } catch (profileError) {
              console.error("Failed to get LIFF profile:", profileError);
              // Continue without profile picture/name if possible, but need Line ID
              if (!userState.lineId) {
                 showAlert("ข้อผิดพลาด", "ไม่สามารถดึงข้อมูลโปรไฟล์ LINE ได้");
                 // Depending on how critical the profile data is, you might want to exit here.
                 // For now, we proceed assuming lineId might be obtained later or is not strictly needed for initial fetch.
                 // However, our GAS calls REQUIRE lineId, so failing to get it here is a problem.
                 // Let's assume getProfile() will eventually yield userId or fail critically.
                 return false; // Exit if profile failed to get user ID
              }
          }
      }

      pointValEl.textContent = '...'; // Show loading for points

      // Fetch initial data from GAS
      try {
        const [userRes, histRes, eventsRes, redeemRes, settingsRes] = await Promise.all([
          fetch(`${CONFIG.GAS_URL}?action=getUserInfo&lineId=${userState.lineId}`),
          fetch(`${CONFIG.GAS_URL}?action=getHistory&lineId=${userState.lineId}`),
          fetch(`${CONFIG.GAS_URL}?action=getEvents`),
          fetch(`${CONFIG.GAS_URL}?action=getItems`),
          fetch(`${CONFIG.GAS_URL}?action=getLevelConfig`)
        ]);

        const userData = await userRes.json();
        const historyData = await histRes.json();
        dataCache.events = await eventsRes.json();
        dataCache.redeemItems = await redeemRes.json();
        const settingsData = await settingsRes.json();

        // Process settings
        if (settingsData && !settingsData.error) { dataCache.levelSettings = { VIP_points: parseInt(settingsData.VIP_points || 0), SUPER_points: parseInt(settingsData.SUPER_points || 0) }; }
        else { console.warn("Failed to load level settings, using defaults."); dataCache.levelSettings = { VIP_points: 5000, SUPER_points: 10000 }; }

        // Check registration status
        if (!userData || !userData.isRegistered) {
            console.log("User not registered, redirecting to register page.");
            window.location.href = 'register.html';
            return false;
        }

        // Update user state from fetched data
        userState.points = parseInt(userData.point || 0, 10);
        userState.level = userData.level || 'Member';
        userState.customTag = userData.customTag || '';
        dataCache.userProfileFull = userData; // Cache full user data including profile fields

        // Update UI with points
        pointValEl.textContent = userState.points;

        // Cache history
        dataCache.history = historyData;
        userState.pointsChanged = false; // Reset flag after fetching history

        console.log("Initial data fetch successful.");
        return true; // Indicate successful initialization and data fetch

      } catch (error) {
        console.error("Failed to fetch initial data from GAS:", error);
        pointValEl.textContent = 'N/A';
        showAlert("ข้อผิดพลาด", "ไม่สามารถโหลดข้อมูลผู้ใช้ได้ กรุณาลองใหม่");
        return false; // Indicate failure
      }
    }


    // --- ROUTER ---
    const routes = {
      '#dashboard': { title: 'CRM-3RN', tpl: 'view-dashboard', init: initDashboard },
      '#event': { title: 'กิจกรรม', tpl: 'view-event', init: initEvent },
      '#event-detail': { title: 'รายละเอียดกิจกรรม', tpl: 'view-event-detail', init: initEventDetail },
      '#profile': { title: 'โปรไฟล์ของคุณ', tpl: 'view-profile', init: initProfile },
      '#redeem': { title: 'ร้านค้าแลกของรางวัล', tpl: 'view-redeem', init: initRedeem },
      '#transfer': { title: 'โอนพ้อยให้เพื่อน', tpl: 'view-transfer', init: initTransfer },
      '#warehouse': { title: 'คลังของรางวัล', tpl: 'view-warehouse', init: initWarehouse },
      '#addpoint': { title: 'โค้ดเพื่อรับรางวัล', tpl: 'view-addpoint', init: initAddpoint },
      '': { title: 'CRM-3RN', tpl: 'view-dashboard', init: initDashboard }
    };
    async function router() {
      // Clear any active polling interval before changing view
      if (warehousePollingInterval) {
         clearInterval(warehousePollingInterval);
         warehousePollingInterval = null;
         console.log("Polling stopped due to route change.");
      }
       // Close the QR dialog if it's open when route changes
       if (qrDialog && qrDialog.open) {
           qrDialog.close();
           console.log("QR Dialog closed due to route change.");
       }


      const hash = window.location.hash.split('?')[0] || '';
      const route = routes[hash] || routes[''];
      pageTitleEl.textContent = route.title;
      const appDiv = document.getElementById('app'); appDiv.innerHTML = '';
      const template = document.getElementById(route.tpl);
      if (template) { appDiv.appendChild(template.content.cloneNode(true)); }
      else { appDiv.innerHTML = `<p class="text-center text-red-500 py-8">เกิดข้อผิดพลาด: ไม่พบเทมเพลตสำหรับ ${hash}</p>`; return; }
      try { await route.init(); }
      catch (error) { console.error(`Error initializing view ${route.tpl}:`, error); showAlert('เกิดข้อผิดพลาด', 'ไม่สามารถโหลดข้อมูลหน้านี้ได้'); }
    }

    // --- SKELETONS & HELPERS ---
    function generateListSkeleton(count) { return Array.from({ length: count }).map(_ => `<li class="flex justify-between items-center animate-pulse py-3"><div class="space-y-2 flex-1"><div class="h-4 bg-gray-200 rounded w-1/2"></div><div class="h-3 bg-gray-200 rounded w-1/3 mt-1"></div></div><div class="h-6 w-12 bg-gray-200 rounded-full"></div></li>`).join(""); }
    function generateCardSkeleton(count) { return Array.from({ length: count }).map(_ => `<li class="bg-white p-4 rounded shadow-sm loading-card-animation"><div class="h-24 bg-gray-200 rounded-md mb-3"></div><div class="h-4 bg-gray-200 rounded w-2/3 mb-2"></div><div class="h-3 bg-gray-200 rounded w-1/2 mb-3"></div><div class="h-8 bg-gray-200 rounded-full w-full"></div></li>`).join(''); }
    function renderHistoryList(historyData) {
      const el = document.getElementById('historyList'); if (!el) return;
      // Sort by date descending and take the latest 10
      const latest = historyData.sort((a, b) => new Date(b.date.split(' ')[0].split('/').reverse().join('/') + ' ' + b.date.split(' ')[1]) - new Date(a.date.split(' ')[0].split('/').reverse().join('/') + ' ' + a.date.split(' ')[1])).slice(0, 10);
      if (latest.length === 0) { el.innerHTML = `<li class="text-center text-gray-400 py-4">ไม่มีประวัติการทำรายการ</li>`; return; }
      el.innerHTML = latest.map(item => {
        const isDebit = ['redeem', 'transfer_out'].includes(item.type);
        return `<li class="flex justify-between items-center"><div><div class="font-medium text-gray-800 text-sm">${item.detail}</div><div class="text-xs text-gray-400 mt-1">${item.date}</div></div><div class="text-sm font-bold px-4 py-1.5 rounded-full ${isDebit ? 'bg-red-100 text-red-700' : 'bg-green-100 text-green-700'}">${isDebit ? '-' : '+'} ${item.amount}</div></li>`;
      }).join("");
    }
    async function getFreshOrCachedHistory() {
      if (userState.pointsChanged || !dataCache.history) {
        try {
          const res = await fetch(`${CONFIG.GAS_URL}?action=getHistory&lineId=${userState.lineId}`);
          dataCache.history = await res.json(); userState.pointsChanged = false;
        } catch (e) { console.error("Error fetching history:", e); dataCache.history = []; userState.pointsChanged = false; }
      } return dataCache.history;
    }

    // --- VIEW INITIALIZATION FUNCTIONS ---
    async function initDashboard() {
      const historyListEl = document.getElementById('historyList'), checkinBox = document.getElementById('checkinBox'), todayDateEl = document.getElementById('todayDate'), checkinBtn = document.getElementById('checkinBtn');
      // Use cached history first if available and points haven't changed
      if (dataCache.history && !userState.pointsChanged) {
           renderHistoryList(dataCache.history);
      } else {
          // Show skeleton while waiting for fresh data
          if (historyListEl) historyListEl.innerHTML = generateListSkeleton(5);
      }

      try {
        // Fetch checkin status and fresh history concurrently
        const [checkRes, history] = await Promise.all([
            fetch(`${CONFIG.GAS_URL}?action=checkinStatus&lineId=${userState.lineId}`).then(r => r.json()),
            getFreshOrCachedHistory() // This will fetch if needed, or use cached
        ]);

        // Render history with fetched/cached data
        renderHistoryList(history);

        // Handle checkin UI
        if (checkRes && !checkRes.checkedInToday) {
          checkinBox.classList.remove('hidden');
          todayDateEl.textContent = new Date().getDate().toString().padStart(2, "0");
          checkinBtn.onclick = async () => {
            checkinBtn.disabled = true;
            try {
              const res = await fetch(CONFIG.GAS_URL, { method: 'POST', body: JSON.stringify({ action: "dailyCheckin", lineId: userState.lineId }) });
              const text = await res.text();
              showAlert('เช็คอินสำเร็จ', text, async () => {
                  if (text.includes("สำเร็จ")) {
                      await fetchAndUpdateUserState(); // Update points and user state
                      // After successful checkin and state update, re-initialize dashboard
                      // This ensures history and checkin status are correctly reflected
                       initDashboard(); // Re-run init to update history and hide checkin box
                  }
              });
            } catch (e) {
                console.error("Check-in failed:", e);
                showAlert('ข้อผิดพลาด', 'ไม่สามารถเช็คอินได้');
            } finally {
                checkinBtn.disabled = false;
            }
          };
        } else if (checkinBox) {
            checkinBox.classList.add('hidden');
        }
      } catch (e) {
          console.error("Error in initDashboard fetch:", e);
          if (historyListEl && historyListEl.innerHTML.includes('animate-pulse')) {
              historyListEl.innerHTML = `<li class="text-center text-red-500 py-4">เกิดข้อผิดพลาดในการโหลดข้อมูล</li>`;
          }
          if (checkinBox) checkinBox.classList.add('hidden'); // Hide checkin box on error
      }
    }


    async function initEvent() {
      const eventListEl = document.getElementById('eventList');
       if (eventListEl) eventListEl.innerHTML = generateListSkeleton(5); // Show skeleton immediately

      let events = dataCache.events; // Try using cached data first
      if (!events) {
        try {
            const res = await fetch(`${CONFIG.GAS_URL}?action=getEvents`);
            events = await res.json();
            if (events.error) throw new Error(events.error); // Throw if GAS returns error
            dataCache.events = events; // Cache fetched data
        } catch (e) {
            console.error("Error fetching events:", e);
            if (eventListEl) eventListEl.innerHTML = `<div class="text-center text-red-500 py-8">เกิดข้อผิดพลาดในการโหลดกิจกรรม</div>`;
            return; // Exit if data fetch fails
        }
      }

      if (!events || events.length === 0) {
          eventListEl.innerHTML = `<div class="text-center text-gray-400 py-8">ไม่มีกิจกรรมในขณะนี้</div>`;
          return; // Exit if no events
      }

      // Filter events based on user level
      const filteredEvents = events.filter(e =>
          !e.allowedLevels || e.allowedLevels.length === 0 || e.allowedLevels.includes(userState.level)
      );

      if (filteredEvents.length === 0) {
          eventListEl.innerHTML = `<div class="text-center text-gray-400 py-8">ไม่มีกิจกรรมสำหรับระดับของคุณ</div>`;
          return; // Exit if no events match level
      }

      // Render the filtered event list
      eventListEl.innerHTML = filteredEvents.map(e => `
        <div class="bg-white rounded p-4 flex justify-between items-center shadow-sm">
          <div>
            <div class="font-semibold text-gray-800 text-sm">${e.title}</div>
            <div class="text-xs text-gray-500">${e.detail || 'ดูรายละเอียดกิจกรรม'}</div>
          </div>
          <a href="#event-detail?id=${e.id}" class="btn btn-neutral">ดูรายละเอียด</a>
        </div>
      `).join('');
    }


    async function initEventDetail() {
      const params = new URLSearchParams(window.location.hash.split('?')[1]);
      const eventId = params.get("id");
      const cardWrapper = document.getElementById('cardWrapper');
      const cardSkeleton = document.getElementById('cardSkeleton');
      const card = document.getElementById('card');
      const titleEl = document.getElementById('eventDetailTitle');
      const descEl = document.getElementById('eventDetailDesc');
      const pointEl = document.getElementById('eventPoint');
      const joinBtn = document.getElementById('joinBtn');

      // Show skeleton and hide actual card initially
      if(cardSkeleton && card) {
          cardSkeleton.classList.remove('hidden');
          card.classList.add('hidden');
      }


      let eventData = dataCache.eventDetails[eventId]; // Try using cached data
      if (!eventData) {
        try {
            const res = await fetch(`${CONFIG.GAS_URL}?action=getEventById&id=${eventId}`);
            const data = await res.json();
            if (data.error) throw new Error(data.error);
            eventData = data;
            dataCache.eventDetails[eventId] = eventData; // Cache fetched data
        } catch (e) {
            console.error("Error fetching event detail:", e);
            eventData = { error: e.message || "ไม่สามารถโหลดรายละเอียดได้" }; // Set an error object
        }
      }

      const history = await getFreshOrCachedHistory(); // Get history to check if joined


      // Update UI based on eventData
      if (eventData.error) {
          titleEl.textContent = "ไม่พบกิจกรรม";
          descEl.textContent = eventData.error;
          pointEl.textContent = 'N/A';
          joinBtn.textContent = "ไม่สามารถเข้าร่วมได้";
          joinBtn.disabled = true;
      } else {
          titleEl.textContent = eventData.title;
          pointEl.textContent = `${eventData.point}+`;
          descEl.textContent = eventData.desc;

          // Check if user has already joined this event
          const hasJoined = history.some(item => item.type === 'event' && String(item.eventId) === String(eventId));

          // Check if user level is allowed
          const isLevelAllowed = !eventData.allowedLevels || eventData.allowedLevels.length === 0 || eventData.allowedLevels.includes(userState.level);

          if (hasJoined) {
              joinBtn.textContent = "รับพ้อยต์แล้ว";
              joinBtn.disabled = true;
          } else if (!isLevelAllowed) {
              joinBtn.textContent = `สำหรับระดับ ${eventData.allowedLevels.join(', ')}`;
              joinBtn.disabled = true;
          } else {
              // Event can be joined
              joinBtn.textContent = "เข้าร่วม";
              joinBtn.disabled = false;
              joinBtn.onclick = async () => {
                if (!(await showConfirm('ยืนยัน', `เข้าร่วม "${eventData.title}" และรับ ${eventData.point} พ้อยต์?`))) return;
                joinBtn.disabled = true;
                joinBtn.textContent = "กำลังเข้าร่วม...";
                try {
                  const res = await fetch(CONFIG.GAS_URL, { method: "POST", body: JSON.stringify({ action: "joinEvent", lineId: userState.lineId, eventId: eventId, title: eventData.title, point: eventData.point }) }); // Ensure eventId is sent
                  const text = await res.text();
                  showAlert("สถานะ", text, async () => {
                       // Reload user state and history after successful join
                      if (text.includes("สำเร็จ")) {
                          await fetchAndUpdateUserState();
                          // Update history cache directly or re-fetch for accuracy
                           const newHistoryItem = {
                                type: 'event',
                                detail: `ร่วมกิจกรรม: ${eventData.title}`,
                                amount: eventData.point,
                                date: new Date().toLocaleString('th-TH', { timeZone: 'Asia/Bangkok' }), // Approximate date format
                                eventId: eventId
                            };
                            if(dataCache.history) dataCache.history.push(newHistoryItem); else dataCache.history = [newHistoryItem];
                            userState.pointsChanged = false; // Mark history as fresh

                          joinBtn.textContent = "รับพ้อยต์แล้ว"; // Update button text
                           joinBtn.disabled = true; // Disable button permanently
                      } else {
                           // If joining failed, re-enable button
                           joinBtn.textContent = "เข้าร่วม";
                           joinBtn.disabled = false;
                      }
                  });
                } catch (e) {
                    console.error("Join event failed:", e);
                    showAlert('ข้อผิดพลาด', 'ไม่สามารถเข้าร่วมได้');
                    joinBtn.textContent = "เข้าร่วม"; // Re-enable button on error
                    joinBtn.disabled = false;
                }
              };
          }
      }

      // Hide skeleton and show actual card
      if(cardSkeleton && card) {
          cardSkeleton.classList.add("hidden");
          card.classList.remove("hidden");
      }
    }


    async function initProfile() {
      const dpEl = document.getElementById('profileDisplayPicture'), dnEl = document.getElementById('profileDisplayName'), lineIdEl = document.getElementById('profileLineId'), levelBadgeEl = document.getElementById('profileLevelBadge'), tagBadgeEl = document.getElementById('profileCustomTagBadge'), progressEl = document.getElementById('profileProgressBar'), progressTextEl = document.getElementById('profilePointsToNextLevel'), totalPointsEl = document.getElementById('profileTotalPoints'), nameEl = document.getElementById('profileName'), phoneEl = document.getElementById('profilePhone'), emailEl = document.getElementById('profileEmail'), addressEl = document.getElementById('profileAddress'), noteEl = document.getElementById('profileNote'), editBtn = document.getElementById('editProfileBtn'), formContainer = document.getElementById('profileFormContainer'), editButtonsDiv = document.getElementById('profileEditButtons'), saveBtn = document.getElementById('saveProfileBtn'), cancelBtn = document.getElementById('cancelEditBtn');
      const editableInputs = [nameEl, phoneEl, emailEl, addressEl, noteEl]; let initialData = {};

      // Display basic profile info from LIFF and current points/level
      dpEl.src = userState.profile?.pictureUrl || 'https://via.placeholder.com/96';
      dnEl.textContent = userState.profile?.displayName || 'กำลังโหลด...';
      lineIdEl.value = userState.lineId || 'กำลังโหลด...';
      totalPointsEl.textContent = userState.points.toLocaleString();

      const { level, progressValue, pointsToNext, nextLevelName } = calculateLevelAndProgress(userState.points);
      setBadgeContent(levelBadgeEl, LEVEL_STYLES[userState.level]?.text || userState.level, `badge badge-lg ${LEVEL_STYLES[userState.level]?.class || ''}`);
      const primaryTag = (userState.customTag.split(',')[0] || '').trim().toLowerCase();
      const tagInfo = CUSTOM_TAG_STYLES[primaryTag] || CUSTOM_TAG_STYLES['default'];
      const tagText = tagInfo.text || (primaryTag ? primaryTag.charAt(0).toUpperCase() + primaryTag.slice(1) : '');
      if (!tagText) tagBadgeEl.classList.add('hidden'); else setBadgeContent(tagBadgeEl, tagText, `badge badge-lg ${tagInfo.class}`);
      progressEl.value = progressValue;
      progressTextEl.textContent = nextLevelName ? `อีก ${pointsToNext.toLocaleString()} พ้อยต์สู่ ${nextLevelName}` : `คุณอยู่ระดับสูงสุดแล้ว!`;

      // Fetch/Use cached full profile data for the form
      let uData = dataCache.userProfileFull;
      if (!uData) {
          try {
              const res = await fetch(`${CONFIG.GAS_URL}?action=getUserInfo&lineId=${userState.lineId}`);
              uData = await res.json();
              if (!uData.error) dataCache.userProfileFull = uData;
              else {
                  console.error("Failed to fetch full profile data:", uData.error);
                  showAlert('ข้อผิดพลาด', 'ไม่สามารถโหลดข้อมูลโปรไฟล์เพิ่มเติมได้');
                  uData = dataCache.userProfileFull || {}; // Use partial cached or empty
              }
          } catch (e) {
              console.error("Error fetching full profile data:", e);
              showAlert('ข้อผิดพลาด', 'ไม่สามารถโหลดข้อมูลโปรไฟล์เพิ่มเติมได้');
              uData = dataCache.userProfileFull || {}; // Use partial cached or empty
          }
      }

      // Populate the form fields
      initialData = {
          name: uData.name || '',
          phone: uData.phone || '',
          email: uData.email || '',
          address: uData.address || '',
          note: uData.note || ''
      };
      nameEl.value = initialData.name;
      phoneEl.value = initialData.phone;
      emailEl.value = initialData.email;
      addressEl.value = initialData.address;
      noteEl.value = initialData.note;


      const toggleEditMode = (enable) => {
        editableInputs.forEach(input => { input.readOnly = !enable; input.classList.toggle('input-neutral', enable); input.classList.toggle('cursor-not-allowed', !enable); input.classList.toggle('text-gray-500', !enable); });
        formContainer.classList.toggle('hidden', !enable);
        editBtn.classList.toggle('hidden', enable);
        editButtonsDiv.classList.toggle('hidden', !enable);
      };

      editBtn.onclick = () => toggleEditMode(true);
      cancelBtn.onclick = () => {
          // Revert changes in form inputs
          Object.keys(initialData).forEach(k => {
              const el = document.getElementById(`profile${k.charAt(0).toUpperCase() + k.slice(1)}`);
              if(el) el.value = initialData[k];
          });
          toggleEditMode(false); // Exit edit mode
      };

      saveBtn.onclick = async () => {
        saveBtn.disabled = true;
        cancelBtn.disabled = true;
        try {
          const body = {
              action: 'updateProfile',
              lineId: userState.lineId,
              name: nameEl.value,
              phone: phoneEl.value,
              email: emailEl.value,
              address: addressEl.value,
              note: noteEl.value
          };
          const res = await fetch(CONFIG.GAS_URL, { method: 'POST', body: JSON.stringify(body) });
          const text = await res.text();

          showAlert("สถานะ", text, async () => {
               // If update was successful according to GAS response
              if (text.includes("สำเร็จ")) {
                  // Refetch and update user state (including full profile data cache)
                  await fetchAndUpdateUserState();
                  // Update initialData with newly saved values for next edit session
                  initialData = {
                      name: nameEl.value,
                      phone: phoneEl.value,
                      email: emailEl.value,
                      address: addressEl.value,
                      note: noteEl.value
                  };
                  toggleEditMode(false); // Exit edit mode
              }
              // If update failed, keep the form open and re-enable buttons (handled in finally)
          });
        } catch (e) {
            console.error("Update profile failed:", e);
            showAlert('ข้อผิดพลาด', 'ไม่สามารถอัปเดตได้');
        } finally {
            saveBtn.disabled = false;
            cancelBtn.disabled = false;
        }
      };

      // Initialize in view mode
      toggleEditMode(false);
      formContainer.classList.remove('hidden'); // Ensure form container is visible in view mode too
    }


    async function initRedeem() {
        const redeemListEl = document.getElementById('redeemList');
         if (redeemListEl) redeemListEl.innerHTML = generateCardSkeleton(4); // Show skeleton

        let items = dataCache.redeemItems; // Use cached items first
        if (!items) {
            try {
                const res = await fetch(`${CONFIG.GAS_URL}?action=getItems`);
                items = await res.json();
                if (items.error) throw new Error(items.error);
                dataCache.redeemItems = items; // Cache fetched items
            } catch (e) {
                console.error("Error fetching items:", e);
                if (redeemListEl) redeemListEl.innerHTML = `<li class="col-span-2 text-center text-red-500 py-4">เกิดข้อผิดพลาดในการโหลดของรางวัล</li>`;
                return; // Exit if fetch fails
            }
        }

        if (!items || items.length === 0) {
            redeemListEl.innerHTML = `<li class="col-span-2 text-center text-gray-400 py-4">ไม่มีของรางวัลให้แลก</li>`;
            return; // Exit if no items
        }

        // Render the item list
        redeemListEl.innerHTML = items.map(item => `
            <li class="bg-white p-4 rounded shadow-sm text-center flex flex-col justify-between">
                <div>
                  <img src="${item.image}" alt="${item.name}" class="h-24 w-full object-cover mx-auto mb-2 rounded-md">
                  <div class="font-bold mb-1">${item.name}</div>
                  <div class="text-sm text-gray-600 mb-2">${item.point} พ้อยต์</div>
                </div>
                <button
                    data-item-id="${item.id}"
                    data-item-name="${item.name}"
                    data-item-point="${item.point}"
                    data-item-type="${item.type}"
                    class="redeem-btn btn btn-neutral btn-sm mt-2">
                    แลกเลย
                </button>
            </li>
        `).join('');

        // Add event listeners to the buttons
        document.querySelectorAll('.redeem-btn').forEach(btn => {
            btn.addEventListener('click', handleRedeemClick);
        });
    }


    async function handleRedeemClick(event) {
        const btn = event.currentTarget;
        const { itemId, itemName, itemPoint, itemType } = btn.dataset;
        const point = parseInt(itemPoint, 10);

        // Check if user has enough points
        if (userState.points < point) {
            showAlert("ไม่เพียงพอ", `แต้มของคุณ (${userState.points}) ไม่พอสำหรับแลก "${itemName}" ซึ่งใช้ ${point} พ้อยต์`);
            return;
        }

        // If physical item, show shipping form
        if (itemType === 'physical') {
            showShippingForm({ itemId, itemName, point });
        } else { // If digital or other type, confirm and redeem directly
            const confirmed = await showConfirm(`ยืนยันการแลก`, `แลก "${itemName}" ด้วย ${point} พ้อยต์ ใช่หรือไม่?`);
            if (!confirmed) return;
            await executeRedemption(btn, { itemId, point }); // No shipping info needed
        }
    }

    function showShippingForm(item) {
        const dialog = document.getElementById('shippingFormDialog');
        const titleEl = document.getElementById('shippingFormTitle');
        const nameInput = document.getElementById('shippingName');
        const phoneInput = document.getElementById('shippingPhone');
        const addressInput = document.getElementById('shippingAddress');
        const confirmBtn = document.getElementById('shippingFormConfirmBtn');
        const cancelBtn = document.getElementById('shippingFormCancelBtn');

        titleEl.textContent = `ข้อมูลจัดส่งสำหรับ: ${item.itemName}`;

        // Populate form with cached profile data
        const profile = dataCache.userProfileFull || {};
        nameInput.value = profile.name || '';
        phoneInput.value = profile.phone || '';
        addressInput.value = profile.address || '';

        dialog.showModal();

        // Remove previous listeners to prevent duplicates
        const oldConfirmBtn = confirmBtn.cloneNode(true);
        confirmBtn.parentNode.replaceChild(oldConfirmBtn, confirmBtn);
        const newConfirmBtn = oldConfirmBtn; // Renamed for clarity

        const oldCancelBtn = cancelBtn.cloneNode(true);
        cancelBtn.parentNode.replaceChild(oldCancelBtn, cancelBtn);
        const newCancelBtn = oldCancelBtn; // Renamed for clarity


        const handleConfirm = async () => {
            const shippingName = nameInput.value.trim();
            const shippingPhone = phoneInput.value.trim();
            const shippingAddress = addressInput.value.trim();

            if (!shippingName || !shippingPhone || !shippingAddress) {
                showAlert("ข้อมูลไม่ครบ", "กรุณากรอกชื่อ, เบอร์โทร, และที่อยู่ให้ครบถ้วน");
                return;
            }

            dialog.close(); // Close form dialog
            // Find the original redeem button based on itemId to update its state
            const originalButton = document.querySelector(`.redeem-btn[data-item-id="${item.itemId}"]`);

            // Proceed with redemption including shipping info
            await executeRedemption(originalButton, {
                itemId: item.itemId,
                point: item.point,
                shippingInfo: { name: shippingName, phone: shippingPhone, address: shippingAddress }
            });
        };

        newConfirmBtn.addEventListener('click', handleConfirm);
        newCancelBtn.addEventListener('click', () => dialog.close());

        // Optional: Add a close listener to reset form or state if needed
        // dialog.addEventListener('close', () => { ... });
    }


    async function executeRedemption(buttonElement, payload) {
        // Disable the button during the process
        if(buttonElement) {
           buttonElement.disabled = true;
           buttonElement.textContent = "กำลังแลก...";
        }


        try {
            const body = {
                action: 'redeemItem',
                lineId: userState.lineId,
                itemId: payload.itemId,
                point: payload.point,
                // Include shippingInfo only if present
                ...(payload.shippingInfo && { shippingInfo: payload.shippingInfo })
            };

            const res = await fetch(CONFIG.GAS_URL, { method: 'POST', body: JSON.stringify(body) });
            const text = await res.text();

            showAlert("สถานะการแลก", text, async () => {
                if (text.includes("สำเร็จ")) {
                    // On success, update user state (points will decrease) and refresh history cache
                    await fetchAndUpdateUserState();

                    // Find and update the button state in the list
                    const updatedButton = document.querySelector(`.redeem-btn[data-item-id="${payload.itemId}"]`);
                    if(updatedButton) {
                        updatedButton.textContent = "แลกแล้ว";
                        updatedButton.disabled = true;
                    }

                    // If it was a physical item, user might want to go to warehouse view
                    // Optional: Redirect to warehouse or suggest going there
                    // if (payload.shippingInfo) {
                    //    showConfirm("เพิ่มในคลังแล้ว", "รายการถูกเพิ่มในคลังของคุณแล้ว\nต้องการไปที่คลังเพื่อดู QR Code หรือไม่?").then(go => {
                    //        if(go) window.location.hash = '#warehouse';
                    //    });
                    // }

                } else {
                    // On failure, re-enable the button if it exists
                    if(buttonElement) {
                        buttonElement.disabled = false;
                        buttonElement.textContent = "แลกเลย";
                    }
                }
            });
        } catch (e) {
            console.error("Redemption failed:", e);
            showAlert('ข้อผิดพลาด', 'ไม่สามารถทำรายการแลกของได้ กรุณาลองใหม่');
            // On error, re-enable the button if it exists
            if(buttonElement) {
               buttonElement.disabled = false;
               buttonElement.textContent = "แลกเลย";
            }
        }
    }


    async function initTransfer() {
      const toEl = document.getElementById('transferTo'), amountEl = document.getElementById('transferAmount'), transferBtn = document.getElementById('transferBtn');
      transferBtn.onclick = async () => {
          const to = toEl.value.trim(), amount = parseInt(amountEl.value, 10);

          // Basic validation
          if (!to) { showAlert("ข้อผิดพลาด", "กรุณากรอก LINE ID / เบอร์โทรปลายทาง"); return; }
          if (isNaN(amount) || amount <= 0) { showAlert("ข้อผิดพลาด", "กรุณากรอกจำนวนพ้อยต์ให้ถูกต้อง"); return; }
          if (to === userState.lineId) { showAlert("ข้อผิดพลาด", "ไม่สามารถโอนให้ตัวเอง"); return; }
          if (userState.points < amount) { showAlert("ไม่เพียงพอ", `แต้มของคุณ (${userState.points}) ไม่พอสำหรับโอน`); return; }

          // Confirmation
          if (!(await showConfirm("ยืนยัน", `โอน ${amount} พ้อยต์ให้ ${to} ใช่หรือไม่?`))) return;

          // Disable button and show loading
          transferBtn.disabled = true;
          transferBtn.textContent = "กำลังโอน...";

          try {
              const res = await fetch(CONFIG.GAS_URL, { method: 'POST', body: JSON.stringify({ action: 'transferPoints', from: userState.lineId, to, amount }) });
              const txt = await res.text();

              showAlert("สถานะ", txt, async () => {
                   // On success, update user state and clear form fields
                  if (/สำเร็จ|เรียบร้อย/.test(txt)) {
                      await fetchAndUpdateUserState();
                      toEl.value = '';
                      amountEl.value = '';
                      // Optional: Suggest going to dashboard to see history
                       // showConfirm("โอนสำเร็จ", "โอนพ้อยท์สำเร็จแล้ว\nต้องการกลับหน้าหลักหรือไม่?").then(go => {
                       //     if(go) window.location.hash = '#dashboard';
                       // });
                  }
                  // If failed, show alert but don't clear form/state
              });
          } catch (e) {
              console.error("Transfer failed:", e);
              showAlert("ข้อผิดพลาด", "ไม่สามารถโอนได้");
          } finally {
              // Re-enable button
              transferBtn.disabled = false;
              transferBtn.textContent = "โอนพ้อย";
          }
      };
    }


    async function initAddpoint() {
      const scanContainer = document.getElementById('scanContainer');
      const scanBtn = document.getElementById('scanBtn');
      const enterBtn = document.getElementById('enterBtn');
      const manualInput = document.getElementById('manualCode');

      // Ensure scanContainer is visible and shows initial inputs
      scanContainer.innerHTML = `
          <button id="scanBtn" class="btn btn-neutral w-full">สแกน QR Code</button>
          <div class="flex space-x-2">
            <input id="manualCode" type="text" placeholder="กรอกโค้ดที่นี่" class="input input-bordered input-neutral flex-1">
            <button id="enterBtn" class="btn btn-neutral">รับโค้ด</button>
          </div>`;

      const currentScanBtn = document.getElementById('scanBtn');
      const currentEnterBtn = document.getElementById('enterBtn');
      const currentManualInput = document.getElementById('manualCode');


      async function processCode(code) {
          if (!code) {
              showAlert('ข้อผิดพลาด', 'ไม่พบข้อมูลในโค้ด');
              return;
          }

          // Check if code is already used in history
          const history = await getFreshOrCachedHistory();
           // Check against both 'code' and 'event' types if code IDs overlap
          if (history.some(item => (item.type === 'code' || item.type === 'event') && String(item.eventId || item.id) === String(code))) { // Added item.id check
              showAlert('รับแล้ว', 'คุณเคยรับโค้ดนี้ไปแล้ว');
              return;
          }

          // Fetch code details from GAS
          try {
              const res = await fetch(`${CONFIG.GAS_URL}?action=getCodeById&id=${code}`);
              const data = await res.json();

              if (data.error) {
                  showAlert('ไม่พบโค้ด', data.error);
                  return;
              }

              // Display code details and accept button
              scanContainer.innerHTML = `
                <div class="bg-white p-6 rounded shadow mb-4 text-center">
                  <div class="font-bold text-lg mb-2">${data.title}</div>
                  <div class="text-sm text-gray-700 mb-4">${data.desc || ''}</div>
                  <div class="font-bold text-yellow-600 mb-4 text-xl">คุณจะได้รับ: ${data.point} พ้อยต์</div>
                  <button id="acceptBtn" class="btn btn-neutral w-full">ยืนยันการรับพ้อยต์</button>
                </div>`;
              document.getElementById('acceptBtn').addEventListener('click', () => joinCode(data));

          } catch (e) {
              console.error("Error processing code:", e);
              showAlert('ข้อผิดพลาด', 'ไม่สามารถประมวลผลโค้ดได้ กรุณาลองใหม่');
               // Optional: Reset UI after error
               // initAddpoint();
          }
      }

      async function joinCode(codeData) {
          const { id: scannedCode, title: codeTitle, point: codePoint } = codeData;

          // Confirmation before joining
          if (!(await showConfirm('ยืนยัน', `คุณต้องการรับพ้อยต์จาก "${codeTitle}" จำนวน ${codePoint} พ้อยต์ใช่หรือไม่?`))) {
               // Optional: Reset UI if confirmation is cancelled
               // initAddpoint();
              return;
          }

          const btn = document.getElementById("acceptBtn");
          if (!btn) return; // Should not happen if UI is set up correctly
          btn.disabled = true;
          btn.textContent = "กำลังดำเนินการ...";

          try {
              const res = await fetch(CONFIG.GAS_URL, {
                  method: "POST",
                  body: JSON.stringify({ action: "joinCode", lineId: userState.lineId, id: scannedCode, title: codeTitle, point: codePoint })
              });
              const text = await res.text();

              if (text.includes("สำเร็จ")) {
                  btn.textContent = "รับพ้อยต์แล้ว"; // Update button text on success
                   // Update user state and history
                  await fetchAndUpdateUserState();
                   const newHistoryItem = {
                         type: 'code',
                         detail: `โค้ด: ${codeTitle}`,
                         amount: codePoint,
                         date: new Date().toLocaleString('th-TH', { timeZone: 'Asia/Bangkok' }),
                         eventId: scannedCode // Use id for code history
                     };
                     if(dataCache.history) dataCache.history.push(newHistoryItem); else dataCache.history = [newHistoryItem];
                     userState.pointsChanged = false;

                  showAlert("สำเร็จ", text, () => {
                      // Redirect back to dashboard after successful claim
                      window.location.hash = '#dashboard';
                  });
              } else {
                  // Show error message from GAS
                  showAlert("เกิดข้อผิดพลาด", text);
                   // Re-initialize the view to allow trying again
                  initAddpoint();
              }
          } catch (e) {
              console.error("Join code failed:", e);
              showAlert('ข้อผิดพลาด', 'ไม่สามารถเชื่อมต่อเพื่อรับพ้อยต์ได้');
              // Re-initialize the view on network error
              initAddpoint();
          }
      }

      // Add event listener for scan button
      if (currentScanBtn) {
          currentScanBtn.onclick = async () => {
              try {
                  // Check if scanning is available in current LIFF environment
                  if (!liff.isApiAvailable('scanCodeV2')) {
                       showAlert('ไม่รองรับ', 'คุณสมบัติการสแกน QR Code ไม่พร้อมใช้งานใน LIFF นี้');
                       return;
                  }
                  const result = await liff.scanCodeV2();
                  if (result && result.value) {
                      console.log("Scanned QR code:", result.value);
                      await processCode(result.value); // Process the scanned text
                  } else {
                      console.log("Scan cancelled or no result.");
                      // Optional: Show a message if scan was cancelled
                      // showAlert('แจ้งเตือน', 'ยกเลิกการสแกน');
                  }
              } catch (e) {
                  // Handle specific user cancellation differently if desired
                  if (e.code !== 'USER_CANCEL') {
                     console.error("Scan failed:", e);
                     showAlert('สแกนไม่สำเร็จ', e.message || 'กรุณาลองใหม่อีกครั้ง');
                  } else {
                      console.log("User cancelled scan.");
                      // No need to show alert for user cancellation
                  }
              }
          };
      }


      // Add event listener for manual entry button
      if (currentEnterBtn && currentManualInput) {
          currentEnterBtn.onclick = () => {
            const codeValue = currentManualInput.value.trim();
            if (codeValue) {
              console.log("Manual code entered:", codeValue);
              processCode(codeValue); // Process the manual code
            } else {
              showAlert('ข้อมูลไม่ครบ', 'กรุณากรอกโค้ด');
            }
          };

          // Optional: Allow pressing Enter key in the input field
          currentManualInput.addEventListener('keypress', (event) => {
              if (event.key === 'Enter') {
                  event.preventDefault(); // Prevent default form submission
                  currentEnterBtn.click(); // Trigger the click event on the button
              }
          });
      }
    }


    // --- WAREHOUSE ---
    async function initWarehouse() {
      // Clear any active polling interval before re-initializing the warehouse view
      if (warehousePollingInterval) {
         clearInterval(warehousePollingInterval);
         warehousePollingInterval = null;
         console.log("Polling stopped due to initWarehouse call.");
      }
       // Close the QR dialog if it's open
       if (qrDialog && qrDialog.open) {
           qrDialog.close();
           console.log("QR Dialog closed due to initWarehouse call.");
       }


      const warehouseListEl = document.getElementById('warehouseList');
      if (warehouseListEl) warehouseListEl.innerHTML = generateListSkeleton(3); // Show skeleton

      try {
        const res = await fetch(`${CONFIG.GAS_URL}?action=getWarehouseItems&lineId=${userState.lineId}`);
        const ownedItems = await res.json();
        if (!ownedItems || ownedItems.error) throw new Error(ownedItems.error || 'Failed to load data');

        if (ownedItems.length === 0) {
          warehouseListEl.innerHTML = '<li class="text-center text-gray-400 py-4">ยังไม่มีของรางวัลในคลังของคุณ</li>';
          return; // Exit if no items
        }

        // Render the list of owned items
        warehouseListEl.innerHTML = ownedItems.map(item => {
          const isClaimed = item.status === 'claimed';
          const statusBadge = `<span class="badge ${isClaimed ? 'badge-success' : 'badge-warning'}">${isClaimed ? 'รับแล้ว' : 'รอรับ'}</span>`;
          // Use uniqueId for QR and Polling
          const actionArea = isClaimed
            ? `<div class="text-xs text-gray-500 mt-1">วันที่รับ: ${item.claimDate || '-'}</div>`
            : `<button class="btn btn-neutral btn-sm claim-btn" data-unique-id="${item.uniqueId}" data-item-name="${item.itemName}" data-warehouse-id="${item.warehouseId}">รับของ</button>`; // Pass unique-id and item-name

          return `<li class="bg-white rounded p-4 shadow-sm flex justify-between items-center">
                    <div><div class="font-semibold text-gray-800 text-sm">${item.itemName}</div><div class="text-xs text-gray-500 mt-1">วันที่แลก: ${item.redeemDate}</div>${statusBadge}</div>
                    <div class="text-right">${actionArea}</div></li>`;
        }).join('');

        // Add event listeners to the claim buttons
        document.querySelectorAll('.claim-btn').forEach(button => button.addEventListener('click', handleClaimButtonClick));

      } catch (e) {
        console.error("Error in initWarehouse fetch:", e);
        showAlert("เกิดข้อผิดพลาด", "ไม่สามารถโหลดคลังของรางวัลได้");
        if (warehouseListEl && warehouseListEl.innerHTML.includes('animate-pulse')) {
            warehouseListEl.innerHTML = `<li class="text-center text-red-500 py-4">เกิดข้อผิดพลาดในการโหลดคลัง</li>`;
        }
      }
    }

    // Function to handle claim button click and show QR Modal
    function handleClaimButtonClick(event) {
        // Clear any existing interval before starting a new one
        if (warehousePollingInterval) {
            clearInterval(warehousePollingInterval);
            warehousePollingInterval = null;
            console.log("Cleared previous polling interval.");
        }

        const btn = event.currentTarget;
        const { uniqueId, itemName } = btn.dataset; // Get data from the button

        // Check if uniqueId is available
        if (!uniqueId) {
             console.error("Missing uniqueId on claim button dataset.");
             showAlert("ข้อผิดพลาด", "ไม่พบข้อมูลสำหรับรับของรายการนี้");
             return;
        }


        // --- Configure and Show QR Modal ---
        qrConfirmBtn.classList.add('hidden'); // Ensure confirm button is hidden
        // Check LIFF capability and show/hide share button
        if (liff.isApiAvailable('shareTargetPicker') || liff.isApiAvailable('sendMessage')) {
             shareQrBtn.classList.remove('hidden');
        } else {
             shareQrBtn.classList.add('hidden');
        }


        qrDialogTitle.textContent = `สแกนเพื่อรับ: ${itemName}`; // Set modal title
        qrDialogItemName.textContent = `Unique ID: ${uniqueId}`; // Display the Unique ID
        qrDialogDescription.textContent = 'ให้พนักงานสแกน QR Code นี้เพื่อตรวจสอบและยืนยันการรับสินค้า'; // Default instruction
        qrcodeContainer.innerHTML = ''; // Clear previous QR or status message
        // Remove any status classes
        qrcodeContainer.classList.remove('text-center', 'text-green-600', 'font-bold', 'text-lg', 'p-4');

        // Generate and display QR Code
        try {
            const qr = qrcode(4, 'L');
            qr.addData(uniqueId); // Data for QR code is the Unique ID
            qr.make();
            qrcodeContainer.innerHTML = qr.createImgTag(6, 4); // Display the QR code image

            // Add event listener for the Share button (if shown)
            // Remove previous listener first to prevent duplicates
            const oldShareQrBtn = document.getElementById('shareQrBtn');
            const newShareQrBtn = oldShareQrBtn.cloneNode(true);
            oldShareQrBtn.parentNode.replaceChild(newShareQrBtn, oldShareQrBtn);

            newShareQrBtn.addEventListener('click', async () => {
                 if (!liff.isApiAvailable('shareTargetPicker') && !liff.isApiAvailable('sendMessage')) {
                     showAlert('ไม่รองรับ', 'คุณสมบัติการแชร์ไม่พร้อมใช้งานใน LIFF นี้');
                     return;
                 }

                 newShareQrBtn.disabled = true; // Disable button during share
                 newShareQrBtn.textContent = 'กำลังแชร์...';

                 // Construct QR Code Image URL (using Google Chart API as an example)
                 const qrCodeApiUrl = `https://chart.googleapis.com/chart?cht=qr&chs=300x300&chl=${encodeURIComponent(uniqueId)}`;

                 // Create Flex Message object
                 const flexMessage = {
                     "type": "flex",
                     "altText": `QR Code รับสินค้า: ${itemName}`,
                     "contents": {
                         "type": "bubble",
                         "header": {
                             "type": "box",
                             "layout": "vertical",
                             "contents": [
                                 { "type": "text", "text": "QR Code รับสินค้า", "weight": "bold", "size": "md" },
                                 { "type": "text", "text": itemName, "size": "sm", "color": "#999999", "margin": "sm" }
                             ]
                         },
                         "hero": {
                             "type": "image",
                             "url": qrCodeApiUrl, // Use the QR image URL
                             "size": "full",
                             "aspectRatio": "1:1",
                             "aspectMode": "fit",
                             "action": { // Optional: Make image clickable
                                 "type": "uri",
                                 "label": "ดู QR Code",
                                 "uri": qrCodeApiUrl
                             }
                         },
                         "body": {
                             "type": "box",
                             "layout": "vertical",
                             "contents": [
                                  { "type": "text", "text": `Unique ID: ${uniqueId}`, "size": "sm", "align": "center", "color": "#666666" },
                                  { "type": "text", "text": `สำหรับรับสินค้าที่เคาน์เตอร์`, "size": "xs", "align": "center", "color": "#888888", "margin": "sm" }
                              ],
                              "paddingAll": "sm",
                              "paddingTop": "none"
                         },
                         "footer": {
                             "type": "box",
                             "layout": "vertical",
                             "contents": [
                                 { "type": "text", "text": "กรุณาแสดงหน้านี้ให้พนักงานสแกน", "size": "sm", "align": "center", "color": "#555555" }
                             ]
                         }
                     }
                 };

                 try {
                    // Determine whether to use sendMessage or shareTargetPicker
                    if (liff.isApiAvailable('shareTargetPicker') && !liff.isInClient()) {
                         // If shareTargetPicker is available AND we are in an external browser, use shareTargetPicker
                         await liff.shareTargetPicker([flexMessage]);
                         // No need to close LIFF after shareTargetPicker
                         // showAlert('แชร์สำเร็จ', 'เลือกผู้รับแล้ว'); // shareTargetPicker doesn't guarantee sending, so simpler alert
                    } else if (liff.isApiAvailable('sendMessage')) {
                         // If sendMessage is available (implies in-app), use sendMessage
                         await liff.sendMessage([flexMessage]);
                         // Consider closing window or showing confirmation after sendMessage
                         // liff.closeWindow();
                          showAlert('แชร์สำเร็จ', 'ส่งข้อความแล้ว');
                    } else {
                         // Fallback if neither is available in this context (should be caught by initial check, but defensive)
                          showAlert('ไม่รองรับ', 'คุณสมบัติการแชร์ไม่พร้อมใช้งาน');
                    }

                 } catch (error) {
                     console.error("Error sending message", error);
                      // Handle specific user cancellation error for shareTargetPicker
                     if (error.code !== 'SHARE_TARGET_PICKER_CANCEL') {
                         showAlert('เกิดข้อผิดพลาด', 'ไม่สามารถแชร์ QR Code ได้: ' + (error.message || error));
                     } else {
                          console.log("Share cancelled by user");
                     }
                 } finally {
                     // Re-enable the share button
                     newShareQrBtn.disabled = false;
                     newShareQrBtn.textContent = 'แชร์ QR ไปยัง LINE OA';
                 }
            });


        } catch(e) {
            // Error generating QR Code
            qrcodeContainer.innerHTML = `<p class="text-red-500">ไม่สามารถสร้าง QR Code ได้</p>`;
            qrcodeContainer.classList.add('text-center'); // Center the error message
            console.error("Error generating QR Code:", e);
            shareQrBtn.classList.add('hidden'); // Hide share button if QR cannot be generated
        }


        // --- Polling Logic ---
        async function checkClaimStatus() {
            console.log(`Polling status for UniqueID: ${uniqueId}...`);
            try {
                // Fetch status from Apps Script using Unique ID
                const res = await fetch(`${CONFIG.GAS_URL}?action=getWarehouseItemStatus&uniqueId=${uniqueId}`);
                const data = await res.json();

                if (data && data.status === 'claimed') {
                    console.log('Item has been claimed!');
                    // Stop polling
                    clearInterval(warehousePollingInterval);
                    warehousePollingInterval = null;
                    console.log("Polling stopped upon receiving 'claimed' status.");

                    // Update Modal UI to show claimed status
                    qrcodeContainer.innerHTML = `
                        <div class="text-center text-green-600 font-bold text-lg p-4">
                            ✅ สินค้า "${itemName}" ถูกรับแล้ว!
                        </div>
                    `;
                     qrcodeContainer.classList.add('text-center', 'text-green-600', 'font-bold', 'text-lg', 'p-4');
                    qrDialogDescription.textContent = 'รายการนี้ถูกบันทึกการรับเรียบร้อยแล้ว';
                    shareQrBtn.classList.add('hidden'); // Hide share button once claimed

                    // Update the "Close" button text
                    qrCloseBtn.textContent = 'ปิด';

                    // No need to immediately close the modal or reload the warehouse list here.
                    // The user will close the modal when ready, and the list will refresh then.

                } else if (data && data.status === 'not_found') {
                     // Case where the item is not found (shouldn't happen if flow is correct)
                     console.error(`Polling: Warehouse item with UniqueID ${uniqueId} not found.`);
                     clearInterval(warehousePollingInterval);
                     warehousePollingInterval = null;
                     console.log("Polling stopped due to 'not_found' status.");
                     qrcodeContainer.innerHTML = `<p class="text-red-500">รายการนี้ไม่ถูกต้องหรือไม่พบในระบบ</p>`;
                      qrcodeContainer.classList.add('text-center');
                     qrDialogDescription.textContent = 'เกิดข้อผิดพลาดในการตรวจสอบรายการ';
                     shareQrBtn.classList.add('hidden');
                     // Optionally close the modal after a short delay
                     // setTimeout(() => qrDialog.close(), 3000);

                } else if (data && data.status === 'pending_claim') {
                     // Status is still pending, do nothing or update a "Waiting..." message
                     console.log(`Polling: Status is still pending.`);
                      // Ensure UI is showing QR if it was changed due to a temp error
                     if (qrcodeContainer.innerHTML === '' || qrcodeContainer.querySelector('img') === null) {
                          // Re-generate QR if somehow missing
                          try {
                            const qr = qrcode(4, 'L');
                            qr.addData(uniqueId);
                            qr.make();
                            qrcodeContainer.innerHTML = qr.createImgTag(6, 4);
                             qrcodeContainer.classList.remove('text-center', 'text-green-600', 'font-bold', 'text-lg', 'p-4');
                             qrDialogDescription.textContent = 'ให้พนักงานสแกน QR Code นี้เพื่อตรวจสอบและยืนยันการรับสินค้า';
                             if (liff.isApiAvailable('shareTargetPicker') || liff.isApiAvailable('sendMessage')) {
                                 shareQrBtn.classList.remove('hidden');
                             }
                          } catch(e) {
                              qrcodeContainer.innerHTML = `<p class="text-red-500">ไม่สามารถสร้าง QR Code ได้</p>`;
                               qrcodeContainer.classList.add('text-center');
                              shareQrBtn.classList.add('hidden');
                              console.error(e);
                          }
                     }

                } else {
                     // Handle other unexpected statuses or transient errors
                     console.warn(`Polling: Received unexpected status or data:`, data);
                     // Continue polling, maybe show a temporary "Waiting..." message in description
                     qrDialogDescription.textContent = 'กำลังรอการยืนยัน...';
                }

            } catch (err) {
                console.error('Polling fetch failed:', err);
                // If network error during polling, stop the timer
                clearInterval(warehousePollingInterval);
                warehousePollingInterval = null;
                console.log("Polling stopped due to fetch error.");
                 qrcodeContainer.innerHTML = `<p class="text-red-500">เกิดข้อผิดพลาดในการตรวจสอบสถานะ. <br>กรุณาลองเปิดหน้านี้ใหม่</p>`;
                  qrcodeContainer.classList.add('text-center');
                 qrDialogDescription.textContent = 'การเชื่อมต่อมีปัญหา';
                 shareQrBtn.classList.add('hidden');
                 // Optionally close the modal after a short delay
                 // setTimeout(() => qrDialog.close(), 3000);
            }
        }

        // Start Polling every 1 second (1000 milliseconds)
        warehousePollingInterval = setInterval(checkClaimStatus, 1000);
        console.log(`Polling started for UniqueID: ${uniqueId} every 1 second.`);


        // --- Modal Close Handling ---
        // Add event listener for the close button - Clears interval and reloads list
        // Use { once: true } so this listener is only active for the current modal instance
        qrCloseBtn.addEventListener('click', () => {
            if (warehousePollingInterval) {
                clearInterval(warehousePollingInterval);
                warehousePollingInterval = null;
                console.log("Polling stopped by Close button click.");
            }
            qrDialog.close();
            // Reload warehouse list after modal is closed to reflect potential status change
            initWarehouse();
        }, { once: true });


        // Add a generic listener for the 'close' event on the dialog - Clears interval and reloads list
        // This handles closing via clicking the backdrop or pressing ESC
        // Use { once: true } so this listener is only active for the current modal instance
         qrDialog.addEventListener('close', () => {
             if (warehousePollingInterval) {
                clearInterval(warehousePollingInterval);
                warehousePollingInterval = null;
                console.log("Polling stopped due to modal 'close' event.");
             }
             // Reload warehouse list after modal is closed
             initWarehouse();
         }, { once: true });


        // Show the modal
        qrDialog.showModal();
    }


    // --- APP START ---
    async function initializeApp() {
      const liffReady = await ensureLIFFAndFetchInitialData();
      if (!liffReady) {
          console.error("App initialization failed.");
          // Depending on the failure cause, you might want to show a specific message or retry
          // The showAlert in ensureLIFFAndFetchInitialData should cover basic messages.
          return; // Stop execution if initial LIFF or data fetch fails
      }

      console.log("App initialized successfully. Setting up router.");
      // Add event listener for hash change to handle routing
      window.addEventListener('hashchange', router);
      // Initial route loading based on current hash
      router();
    }

    // Start the application initialization process
    initializeApp();

</script>
</body>
</html>
